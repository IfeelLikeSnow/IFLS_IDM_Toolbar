-- @description DF95: Build IFLS Main Toolbar MenuSet (v1.0.2 - correct ReaperMenuSet syntax)
-- @version 1.0.5
-- @author DF95 (generated by Reaper DAW Ultimate Assistant)
-- @about
--   FIX: Writes toolbar entries in reaper-menu.ini / ReaperMenuSet syntax:
--     item_0=ACTION  LABEL
--     icon_0=text_wide
--   (Previous ACT/ITEM syntax gets imported but ignored by REAPER, leaving toolbar empty.)
--
--   Output:
--     REAPER\ResourcePath\MenuSets\IFLS_Main.Toolbar.ReaperMenuSet
--
--   Use:
--     Options > Customize menus/toolbars...
--     Select: Floating toolbar 1
--     Import/Export > Import...
--     Choose: IFLS_Main.Toolbar.ReaperMenuSet
--
--   Notes:
--   - Registers referenced scripts as actions to obtain valid _RS... command IDs.
--   - If a script is missing, its button will be written inert as item_N=-1 <Missing...>

local function msg(s) reaper.ShowConsoleMsg(tostring(s) .. "\n") end
local function join(a,b)
  if not a or a=="" then return b end
  local last=a:sub(-1)
  if last=="\\" or last=="/" then return a..b end
  return a.."/"..b
end
local function exists(path)
  local f=io.open(path,"rb")
  if f then f:close(); return true end
  return false
end
local function ensure_dir(path) reaper.RecursiveCreateDirectory(path,0) end
local function normpath(p) return (p or ""):gsub("\\","/") end

local function enum_files_recursive(dir, out, depth, maxdepth)
  out = out or {}
  depth = depth or 0
  maxdepth = maxdepth or 8
  if depth > maxdepth then return out end
  local i = 0
  while true do
    local fn = reaper.EnumerateFiles(dir, i)
    if not fn then break end
    out[#out+1] = join(dir, fn)
    i = i + 1
  end
  local j = 0
  while true do
    local sub = reaper.EnumerateSubdirectories(dir, j)
    if not sub then break end
    enum_files_recursive(join(dir, sub), out, depth + 1, maxdepth)
    j = j + 1
  end
  return out
end

local function find_script_anywhere(filename)
  local base = reaper.GetResourcePath()
  local scripts_dir = normpath(join(base, "Scripts"))
  local preferred = {
    normpath(join(scripts_dir, "IFLS_IDM_Toolbar/Hubs/"..filename)),
    normpath(join(scripts_dir, "IFLS/IFLS/Hubs/"..filename)),
    normpath(join(scripts_dir, "IFLS/Hubs/"..filename)),
    normpath(join(scripts_dir, filename)),
  }
  for _,p in ipairs(preferred) do
    if exists(p) then return p end
  end
  local all = enum_files_recursive(scripts_dir, {}, 0, 8)
  filename = filename:lower()
  for _,p in ipairs(all) do
    if p:lower():sub(-#filename) == filename then
      return normpath(p)
    end
  end
  return nil
end

local function ensure_hub_shim(filename)
  local base = normpath(join(reaper.GetResourcePath(), "Scripts"))
  local hubs_dir = normpath(join(base, "IFLS_IDM_Toolbar/Hubs"))
  local canonical = normpath(join(hubs_dir, filename))
  if exists(canonical) then return canonical, nil end
  local found = find_script_anywhere(filename)
  if not found then return nil, "missing: "..canonical end
  ensure_dir(hubs_dir)
  local shim = ([[-- @description IFLS Hub Shim: %s
-- @version 1.0
-- @author IFLS
-- @about Auto-generated shim to keep stable hub paths for IFLS toolbar.
local target = %q
dofile(target)
]]):format(filename, found)
  local f = io.open(canonical, "wb")
  if not f then return found, "found at "..found..", but could not create shim at "..canonical end
  f:write(shim)
  f:close()
  return canonical, nil
end


local function ensure_named_command(script_abs_path, sectionID)
  if not exists(script_abs_path) then return nil, "missing: "..script_abs_path end
  local cmdID = reaper.AddRemoveReaScript(true, sectionID, script_abs_path, true)
  if not cmdID or cmdID == 0 then
    return nil, "AddRemoveReaScript failed for: "..script_abs_path
  end
  local name = reaper.ReverseNamedCommandLookup(cmdID)
  if not name or name == "" then
    return nil, "ReverseNamedCommandLookup failed for cmdID="..tostring(cmdID)
  end
  return "_"..name, nil
end

-- CONFIG
local resource = reaper.GetResourcePath()
local scripts_root = join(resource, "Scripts")
local SECTION_MAIN = 0

local buttons = {
  {label="IFLS Beat Control Center", script_rel="IFLS_IDM_Toolbar/Hubs/IFLS_BeatControlCenter_ImGui.lua"},
  {label="IFLS Artist Hub",         script_rel="IFLS_IDM_Toolbar/Hubs/IFLS_ArtistHub_ImGui.lua"},
  {label="IFLS SampleGalaxy",       script_rel="IFLS_IDM_Toolbar/Hubs/IFLS_SampleLibraryHub_ImGui.lua"},
  {label="IFLS Groove & Rhythm",    script_rel="IFLS_IDM_Toolbar/Hubs/IFLS_PolyRhythmHub_ImGui.lua"},
  {label="IFLS Macros & Scenes",    script_rel="IFLS_IDM_Toolbar/Hubs/IFLS_SceneHub_ImGui.lua"},
  {label="IFLS FX Brain",           script_rel="IFLS_IDM_Toolbar/Hubs/IFLS_MasterHub_ImGui.lua"},
  {label="IFLS Diagnostics / Inspector", script_rel="IFLS_IDM_Toolbar/DF95/DF95_Diagnostics_Insight_Run.lua"},
  {label="IFLS Dev / Debug",        script_rel="IFLS_IDM_Toolbar/Domain/IFLS_Diagnostics_DebugDemo.lua"},
}

reaper.ClearConsole()
msg("DF95: Build IFLS Main Toolbar MenuSet (v1.0.2 - correct syntax)")
msg("ResourcePath: "..resource)

local resolved={}
local ok_count, miss_count = 0, 0
for i,b in ipairs(buttons) do
  local abs = join(scripts_root, b.script_rel)
  local named, err = ensure_named_command(abs, SECTION_MAIN)
  if named then
    ok_count=ok_count+1
    resolved[#resolved+1]={idx=i-1, cmd=named, label=b.label, missing=false}
    msg(("  OK   %d: %s -> %s"):format(i-1, b.label, named))
  else
    miss_count=miss_count+1
    resolved[#resolved+1]={idx=i-1, cmd="-1", label="MISSING: "..b.label, missing=true, err=tostring(err)}
    msg(("  MISS %d: %s (%s)"):format(i-1, b.label, tostring(err)))
  end
end

local menuSets = join(resource, "MenuSets")
ensure_dir(menuSets)
local out_path = join(menuSets, "IFLS_Main.Toolbar.ReaperMenuSet")

-- IMPORTANT: keep ASCII/UTF-8 without BOM. REAPER may ignore first toolbar if BOM/Unicode weirdness exists.
local f=assert(io.open(out_path,"wb"))
f:write("; DF95/IFLS - IFLS Main Toolbar (generated)\n")
f:write("; Toolbar syntax: item_N=ACTION  LABEL, icon_N=text_wide\n")
f:write("; Import into: Options > Customize menus/toolbars... > Floating toolbar 1 > Import...\n\n")

-- Exact allowed header per REAPER (see reaper-menu.ini rules)
f:write("[Floating toolbar 1]\n")
f:write("title=IFLS Main\n")

for _,it in ipairs(resolved) do
  -- Use text_wide so you see labels even without icons
  f:write(("icon_%d=text_wide\n"):format(it.idx))
  if it.missing then
    -- non-clickable "separator/label" style if missing
    f:write(("item_%d=-1 %s\n"):format(it.idx, it.label))
  else
    f:write(("item_%d=%s %s\n"):format(it.idx, it.cmd, it.label))
  end
end

f:write("\n")
f:close()

msg("")
msg("Wrote: "..out_path)
msg(("Resolved: %d OK, %d missing"):format(ok_count, miss_count))
msg("NEXT: Customize menus/toolbars > Floating toolbar 1 > Import/Export > Import > IFLS_Main.Toolbar.ReaperMenuSet")

reaper.ShowMessageBox("IFLS Toolbar Builder fertig. Prüfe ReaScript Console für Details.", "IFLS Toolbar Builder", 0)
